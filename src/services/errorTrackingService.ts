import { ErrorInfo, ErrorType, ErrorSeverity } from './errorHandler'

export interface ErrorTracker {
  id: string
  timestamp: Date
  error: ErrorInfo
  sessionId: string
  userId?: string
  userAgent: string
  url: string
  stackTrace: string
  context: Record<string, any>
  tags: string[]
  resolved: boolean
  resolutionNote?: string
  resolvedAt?: Date
  resolvedBy?: string
}

export interface ErrorReport {
  totalErrors: number
  errorsByType: Record<ErrorType, number>
  errorsBySeverity: Record<ErrorSeverity, number>
  errorsByComponent: Record<string, number>
  errorsByTime: {
    hourly: Record<string, number>
    daily: Record<string, number>
    weekly: Record<string, number>
  }
  topErrors: ErrorTracker[]
  recentErrors: ErrorTracker[]
  errorTrends: {
    increasing: string[]
    decreasing: string[]
    stable: string[]
  }
}

export interface ErrorFilter {
  types?: ErrorType[]
  severities?: ErrorSeverity[]
  components?: string[]
  dateRange?: {
    start: Date
    end: Date
  }
  tags?: string[]
  resolved?: boolean
  searchQuery?: string
}

export interface ErrorResolution {
  errorId: string
  resolutionNote: string
  resolvedBy: string
  resolutionType: 'fixed' | 'workaround' | 'ignored' | 'investigating'
  nextSteps?: string[]
  estimatedFixTime?: string
}

export class ErrorTrackingService {
  private errorTrackers: Map<string, ErrorTracker> = new Map()
  private errorPatterns: Map<string, ErrorPattern> = new Map()
  private errorMetrics: Map<string, ErrorMetrics> = new Map()
  private sessionId: string

  constructor() {
    this.sessionId = this.generateSessionId()
    this.initializeErrorPatterns()
    this.setupErrorTracking()
  }

  /**
   * ÂàùÂßãÂåñÈåØË™§Ê®°ÂºèË≠òÂà•
   */
  private initializeErrorPatterns(): void {
    // Ê™îÊ°àÁõ∏ÈóúÈåØË™§Ê®°Âºè
    this.errorPatterns.set('file_upload', {
      pattern: /file|upload|download/i,
      category: 'file_operation',
      priority: 'high',
      autoResolution: 'retry',
      suggestions: ['Ê™¢Êü•Ê™îÊ°àÊ†ºÂºè', 'Á¢∫Ë™çÊ™îÊ°àÂ§ßÂ∞è', 'ÈáçË©¶‰∏äÂÇ≥Êìç‰Ωú']
    })

    // Á∂≤Ë∑ØÁõ∏ÈóúÈåØË™§Ê®°Âºè
    this.errorPatterns.set('network_error', {
      pattern: /network|connection|timeout/i,
      category: 'network',
      priority: 'medium',
      autoResolution: 'retry',
      suggestions: ['Ê™¢Êü•Á∂≤Ë∑ØÈÄ£Êé•', 'Á®çÂæåÈáçË©¶', 'Ê™¢Êü•‰º∫ÊúçÂô®ÁãÄÊÖã']
    })

    // È©óË≠âÁõ∏ÈóúÈåØË™§Ê®°Âºè
    this.errorPatterns.set('validation_error', {
      pattern: /validation|invalid|required/i,
      category: 'data_validation',
      priority: 'low',
      autoResolution: 'fix_input',
      suggestions: ['Ê™¢Êü•Ëº∏ÂÖ•Êï∏Êìö', 'Á¢∫Ë™çÂøÖÂ°´Ê¨Ñ‰Ωç', 'È©óË≠âÊï∏ÊìöÊ†ºÂºè']
    })

    // Ê¨äÈôêÁõ∏ÈóúÈåØË™§Ê®°Âºè
    this.errorPatterns.set('permission_error', {
      pattern: /permission|access|unauthorized/i,
      category: 'security',
      priority: 'critical',
      autoResolution: 'manual',
      suggestions: ['Ê™¢Êü•Áî®Êà∂Ê¨äÈôê', 'ËÅØÁπ´ÁÆ°ÁêÜÂì°', 'ÈáçÊñ∞ÁôªÂÖ•Á≥ªÁµ±']
    })

    // Ë≥áÊ∫êÁõ∏ÈóúÈåØË™§Ê®°Âºè
    this.errorPatterns.set('resource_error', {
      pattern: /memory|disk|quota|limit/i,
      category: 'system_resource',
      priority: 'high',
      autoResolution: 'cleanup',
      suggestions: ['Ê∏ÖÁêÜ‰∏çÂøÖË¶ÅÁöÑÊ™îÊ°à', 'ÈáçÂïüÊáâÁî®Á®ãÂºè', 'Ê™¢Êü•Á≥ªÁµ±Ë≥áÊ∫ê']
    })
  }

  /**
   * Ë®≠ÁΩÆÈåØË™§ËøΩËπ§
   */
  private setupErrorTracking(): void {
    // Áõ£ËÅΩÂÖ®ÂüüÈåØË™§‰∫ã‰ª∂
    window.addEventListener('erslice-error', (event: CustomEvent) => {
      this.trackError(event.detail)
    })

    // Áõ£ËÅΩÊú™ËôïÁêÜÁöÑ Promise ÊãíÁµï
    window.addEventListener('unhandledrejection', (event) => {
      this.trackUnhandledRejection(event.reason)
    })

    // Áõ£ËÅΩÂÖ®ÂüüÈåØË™§
    window.addEventListener('error', (event) => {
      this.trackGlobalError(event)
    })
  }

  /**
   * ËøΩËπ§ÈåØË™§
   */
  trackError(errorInfo: ErrorInfo, context?: Record<string, any>): string {
    const tracker: ErrorTracker = {
      id: this.generateErrorId(),
      timestamp: new Date(),
      error: errorInfo,
      sessionId: this.sessionId,
      userId: this.getCurrentUserId(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      stackTrace: errorInfo.stack || '',
      context: context || {},
      tags: this.extractErrorTags(errorInfo),
      resolved: false
    }

    // ÂàÜÊûêÈåØË™§Ê®°Âºè
    this.analyzeErrorPattern(tracker)

    // Êõ¥Êñ∞ÈåØË™§ÊåáÊ®ô
    this.updateErrorMetrics(tracker)

    // Â≠òÂÑ≤ÈåØË™§ËøΩËπ§Âô®
    this.errorTrackers.set(tracker.id, tracker)

    // Ëß∏ÁôºÈåØË™§ËøΩËπ§‰∫ã‰ª∂
    this.triggerErrorTrackedEvent(tracker)

    console.log(`üîç ÈåØË™§Â∑≤ËøΩËπ§: ${tracker.id}`, tracker)
    return tracker.id
  }

  /**
   * ËøΩËπ§Êú™ËôïÁêÜÁöÑ Promise ÊãíÁµï
   */
  private trackUnhandledRejection(reason: any): void {
    const errorInfo: ErrorInfo = {
      id: this.generateErrorId(),
      type: 'unknown',
      severity: 'high',
      message: 'Êú™ËôïÁêÜÁöÑ Promise ÊãíÁµï',
      details: String(reason),
      timestamp: new Date(),
      context: { source: 'unhandled-rejection' },
      recoverable: false,
      retryCount: 0,
      maxRetries: 0,
      suggestions: ['Ê™¢Êü• Promise Èèà', 'Ê∑ªÂä†ÈåØË™§ËôïÁêÜ', '‰ΩøÁî® try-catch']
    }

    this.trackError(errorInfo, { source: 'unhandled-rejection', reason })
  }

  /**
   * ËøΩËπ§ÂÖ®ÂüüÈåØË™§
   */
  private trackGlobalError(event: ErrorEvent): void {
    const errorInfo: ErrorInfo = {
      id: this.generateErrorId(),
      type: 'unknown',
      severity: 'high',
      message: event.message || 'ÂÖ®ÂüüÈåØË™§',
      details: event.error?.stack || '',
      timestamp: new Date(),
      context: { 
        source: 'global-error',
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      },
      recoverable: false,
      retryCount: 0,
      maxRetries: 0,
      suggestions: ['Ê™¢Êü•‰ª£Á¢ºË™ûÊ≥ï', 'Êü•ÁúãÊéßÂà∂Âè∞ÈåØË™§', 'ÈáçÊñ∞ËºâÂÖ•È†ÅÈù¢']
    }

    this.trackError(errorInfo, { 
      source: 'global-error',
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno
    })
  }

  /**
   * ÂàÜÊûêÈåØË™§Ê®°Âºè
   */
  private analyzeErrorPattern(tracker: ErrorTracker): void {
    const message = tracker.error.message.toLowerCase()
    const stack = tracker.error.stack?.toLowerCase() || ''

    for (const [patternName, pattern] of this.errorPatterns.entries()) {
      if (pattern.pattern.test(message) || pattern.pattern.test(stack)) {
        tracker.tags.push(pattern.category)
        tracker.tags.push(`priority:${pattern.priority}`)
        tracker.tags.push(`auto-resolution:${pattern.autoResolution}`)
        
        // Ê∑ªÂä†Ëá™ÂãïËß£ÊûêÂª∫Ë≠∞
        if (pattern.suggestions.length > 0) {
          tracker.context.autoResolutionSuggestions = pattern.suggestions
        }
        
        break
      }
    }
  }

  /**
   * Êõ¥Êñ∞ÈåØË™§ÊåáÊ®ô
   */
  private updateErrorMetrics(tracker: ErrorTracker): void {
    const date = tracker.timestamp.toISOString().split('T')[0]
    const hour = tracker.timestamp.getHours().toString().padStart(2, '0')
    const week = this.getWeekNumber(tracker.timestamp)

    // ÊåâÈ°ûÂûãÁµ±Ë®à
    this.updateMetric('type', tracker.error.type, date)
    
    // ÊåâÂö¥ÈáçÁ®ãÂ∫¶Áµ±Ë®à
    this.updateMetric('severity', tracker.error.severity, date)
    
    // ÊåâÁµÑ‰ª∂Áµ±Ë®à
    const component = tracker.context.component || 'unknown'
    this.updateMetric('component', component, date)
    
    // ÊåâÊôÇÈñìÁµ±Ë®à
    this.updateTimeMetric('hourly', hour, date)
    this.updateTimeMetric('daily', date, date)
    this.updateTimeMetric('weekly', week, date)
  }

  /**
   * Êõ¥Êñ∞ÊåáÊ®ô
   */
  private updateMetric(category: string, key: string, date: string): void {
    const metricKey = `${category}_${key}_${date}`
    const current = this.errorMetrics.get(metricKey) || { count: 0, lastOccurrence: new Date() }
    
    current.count++
    current.lastOccurrence = new Date()
    
    this.errorMetrics.set(metricKey, current)
  }

  /**
   * Êõ¥Êñ∞ÊôÇÈñìÊåáÊ®ô
   */
  private updateTimeMetric(period: string, key: string, date: string): void {
    const metricKey = `time_${period}_${key}_${date}`
    const current = this.errorMetrics.get(metricKey) || { count: 0, lastOccurrence: new Date() }
    
    current.count++
    current.lastOccurrence = new Date()
    
    this.errorMetrics.set(metricKey, current)
  }

  /**
   * ÊèêÂèñÈåØË™§Ê®ôÁ±§
   */
  private extractErrorTags(errorInfo: ErrorInfo): string[] {
    const tags: string[] = []
    
    // Âü∫Êú¨Ê®ôÁ±§
    tags.push(`type:${errorInfo.type}`)
    tags.push(`severity:${errorInfo.severity}`)
    tags.push(`recoverable:${errorInfo.recoverable}`)
    
    // ÁµÑ‰ª∂Ê®ôÁ±§
    if (errorInfo.context.component) {
      tags.push(`component:${errorInfo.context.component}`)
    }
    
    // Êìç‰ΩúÊ®ôÁ±§
    if (errorInfo.context.action) {
      tags.push(`action:${errorInfo.context.action}`)
    }
    
    return tags
  }

  /**
   * Áç≤ÂèñÈåØË™§ËøΩËπ§Âô®
   */
  getErrorTracker(id: string): ErrorTracker | undefined {
    return this.errorTrackers.get(id)
  }

  /**
   * Áç≤ÂèñÊâÄÊúâÈåØË™§ËøΩËπ§Âô®
   */
  getAllErrorTrackers(): ErrorTracker[] {
    return Array.from(this.errorTrackers.values())
  }

  /**
   * ÁØ©ÈÅ∏ÈåØË™§ËøΩËπ§Âô®
   */
  filterErrorTrackers(filter: ErrorFilter): ErrorTracker[] {
    let trackers = Array.from(this.errorTrackers.values())

    // ÊåâÈ°ûÂûãÁØ©ÈÅ∏
    if (filter.types && filter.types.length > 0) {
      trackers = trackers.filter(t => filter.types!.includes(t.error.type))
    }

    // ÊåâÂö¥ÈáçÁ®ãÂ∫¶ÁØ©ÈÅ∏
    if (filter.severities && filter.severities.length > 0) {
      trackers = trackers.filter(t => filter.severities!.includes(t.error.severity))
    }

    // ÊåâÁµÑ‰ª∂ÁØ©ÈÅ∏
    if (filter.components && filter.components.length > 0) {
      trackers = trackers.filter(t => filter.components!.includes(t.context.component || 'unknown'))
    }

    // ÊåâÊó•ÊúüÁØÑÂúçÁØ©ÈÅ∏
    if (filter.dateRange) {
      trackers = trackers.filter(t => 
        t.timestamp >= filter.dateRange!.start && t.timestamp <= filter.dateRange!.end
      )
    }

    // ÊåâÊ®ôÁ±§ÁØ©ÈÅ∏
    if (filter.tags && filter.tags.length > 0) {
      trackers = trackers.filter(t => 
        filter.tags!.some(tag => t.tags.includes(tag))
      )
    }

    // ÊåâËß£Ê±∫ÁãÄÊÖãÁØ©ÈÅ∏
    if (filter.resolved !== undefined) {
      trackers = trackers.filter(t => t.resolved === filter.resolved)
    }

    // ÊåâÊêúÂ∞ãÊü•Ë©¢ÁØ©ÈÅ∏
    if (filter.searchQuery) {
      const query = filter.searchQuery.toLowerCase()
      trackers = trackers.filter(t => 
        t.error.message.toLowerCase().includes(query) ||
        t.error.details?.toLowerCase().includes(query) ||
        t.tags.some(tag => tag.toLowerCase().includes(query))
      )
    }

    return trackers
  }

  /**
   * Ëß£Ê±∫ÈåØË™§
   */
  resolveError(resolution: ErrorResolution): boolean {
    const tracker = this.errorTrackers.get(resolution.errorId)
    if (!tracker) {
      return false
    }

    tracker.resolved = true
    tracker.resolutionNote = resolution.resolutionNote
    tracker.resolvedAt = new Date()
    tracker.resolvedBy = resolution.resolvedBy

    // Êõ¥Êñ∞Ê®ôÁ±§
    tracker.tags.push(`resolution:${resolution.resolutionType}`)
    tracker.tags.push(`resolved-by:${resolution.resolvedBy}`)

    // Ëß∏ÁôºÈåØË™§Ëß£Ê±∫‰∫ã‰ª∂
    this.triggerErrorResolvedEvent(tracker, resolution)

    console.log(`‚úÖ ÈåØË™§Â∑≤Ëß£Ê±∫: ${resolution.errorId}`, resolution)
    return true
  }

  /**
   * ÁîüÊàêÈåØË™§Â†±Âëä
   */
  generateErrorReport(filter?: ErrorFilter): ErrorReport {
    const trackers = filter ? this.filterErrorTrackers(filter) : this.getAllErrorTrackers()
    
    const report: ErrorReport = {
      totalErrors: trackers.length,
      errorsByType: {} as Record<ErrorType, number>,
      errorsBySeverity: {} as Record<ErrorSeverity, number>,
      errorsByComponent: {} as Record<string, number>,
      errorsByTime: {
        hourly: {},
        daily: {},
        weekly: {}
      },
      topErrors: [],
      recentErrors: [],
      errorTrends: {
        increasing: [],
        decreasing: [],
        stable: []
      }
    }

    // Áµ±Ë®àÈåØË™§ÂàÜ‰Ωà
    trackers.forEach(tracker => {
      // ÊåâÈ°ûÂûãÁµ±Ë®à
      report.errorsByType[tracker.error.type] = (report.errorsByType[tracker.error.type] || 0) + 1
      
      // ÊåâÂö¥ÈáçÁ®ãÂ∫¶Áµ±Ë®à
      report.errorsBySeverity[tracker.error.severity] = (report.errorsBySeverity[tracker.error.severity] || 0) + 1
      
      // ÊåâÁµÑ‰ª∂Áµ±Ë®à
      const component = tracker.context.component || 'unknown'
      report.errorsByComponent[component] = (report.errorsByComponent[component] || 0) + 1
    })

    // Áç≤ÂèñÊúÄËøëÈåØË™§
    report.recentErrors = trackers
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, 10)

    // Áç≤ÂèñÊúÄÂ∏∏Ë¶ãÈåØË™§
    report.topErrors = this.getTopErrors(trackers)

    // ÂàÜÊûêÈåØË™§Ë∂®Âã¢
    report.errorTrends = this.analyzeErrorTrends(trackers)

    return report
  }

  /**
   * Áç≤ÂèñÊúÄÂ∏∏Ë¶ãÈåØË™§
   */
  private getTopErrors(trackers: ErrorTracker[]): ErrorTracker[] {
    const errorCounts = new Map<string, { tracker: ErrorTracker; count: number }>()
    
    trackers.forEach(tracker => {
      const key = `${tracker.error.type}_${tracker.error.message}`
      const existing = errorCounts.get(key)
      
      if (existing) {
        existing.count++
      } else {
        errorCounts.set(key, { tracker, count: 1 })
      }
    })

    return Array.from(errorCounts.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 5)
      .map(item => item.tracker)
  }

  /**
   * ÂàÜÊûêÈåØË™§Ë∂®Âã¢
   */
  private analyzeErrorTrends(trackers: ErrorTracker[]): { increasing: string[]; decreasing: string[]; stable: string[] } {
    const trends = { increasing: [] as string[], decreasing: [] as string[], stable: [] as string[] }
    
    // ÈÄôË£°ÂèØ‰ª•ÂØ¶ÁèæÊõ¥Ë§áÈõúÁöÑË∂®Âã¢ÂàÜÊûêÈÇèËºØ
    // ÁõÆÂâçËøîÂõûÁ©∫Êï∏ÁµÑ‰ΩúÁÇ∫‰Ωî‰ΩçÁ¨¶
    
    return trends
  }

  /**
   * Ê∏ÖÁêÜËàäÁöÑÈåØË™§Ë®òÈåÑ
   */
  cleanupOldErrors(daysToKeep: number = 30): number {
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep)
    
    let cleanedCount = 0
    
    for (const [id, tracker] of this.errorTrackers.entries()) {
      if (tracker.timestamp < cutoffDate && tracker.resolved) {
        this.errorTrackers.delete(id)
        cleanedCount++
      }
    }

    console.log(`üßπ Â∑≤Ê∏ÖÁêÜ ${cleanedCount} ÂÄãËàäÈåØË™§Ë®òÈåÑ`)
    return cleanedCount
  }

  /**
   * Â∞éÂá∫ÈåØË™§Êï∏Êìö
   */
  exportErrorData(): string {
    const data = {
      trackers: Array.from(this.errorTrackers.values()),
      metrics: Array.from(this.errorMetrics.entries()),
      patterns: Array.from(this.errorPatterns.entries()),
      exportDate: new Date().toISOString()
    }

    return JSON.stringify(data, null, 2)
  }

  /**
   * Â∞éÂÖ•ÈåØË™§Êï∏Êìö
   */
  importErrorData(jsonData: string): boolean {
    try {
      const data = JSON.parse(jsonData)
      
      if (data.trackers) {
        data.trackers.forEach((tracker: ErrorTracker) => {
          this.errorTrackers.set(tracker.id, tracker)
        })
      }
      
      if (data.metrics) {
        data.metrics.forEach(([key, value]: [string, any]) => {
          this.errorMetrics.set(key, value)
        })
      }
      
      console.log('üì• ÈåØË™§Êï∏ÊìöÂ∞éÂÖ•ÊàêÂäü')
      return true
    } catch (error) {
      console.error('‚ùå ÈåØË™§Êï∏ÊìöÂ∞éÂÖ•Â§±Êïó:', error)
      return false
    }
  }

  /**
   * Ëß∏ÁôºÈåØË™§ËøΩËπ§‰∫ã‰ª∂
   */
  private triggerErrorTrackedEvent(tracker: ErrorTracker): void {
    const event = new CustomEvent('erslice-error-tracked', {
      detail: tracker
    })
    window.dispatchEvent(event)
  }

  /**
   * Ëß∏ÁôºÈåØË™§Ëß£Ê±∫‰∫ã‰ª∂
   */
  private triggerErrorResolvedEvent(tracker: ErrorTracker, resolution: ErrorResolution): void {
    const event = new CustomEvent('erslice-error-resolved', {
      detail: { tracker, resolution }
    })
    window.dispatchEvent(event)
  }

  /**
   * ÁîüÊàêÈåØË™§ ID
   */
  private generateErrorId(): string {
    return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * ÁîüÊàêÊúÉË©± ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * Áç≤ÂèñÁï∂ÂâçÁî®Êà∂ ID
   */
  private getCurrentUserId(): string | undefined {
    // ÈÄôË£°ÂèØ‰ª•ÂØ¶ÁèæÂæûË™çË≠âÁ≥ªÁµ±Áç≤ÂèñÁî®Êà∂ ID ÁöÑÈÇèËºØ
    return localStorage.getItem('erslice-user-id') || undefined
  }

  /**
   * Áç≤ÂèñÈÄ±Êï∏
   */
  private getWeekNumber(date: Date): string {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()))
    const dayNum = d.getUTCDay() || 7
    d.setUTCDate(d.getUTCDate() + 4 - dayNum)
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1))
    return `${d.getUTCFullYear()}-W${Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7)}`
  }
}

interface ErrorPattern {
  pattern: RegExp
  category: string
  priority: 'low' | 'medium' | 'high' | 'critical'
  autoResolution: 'retry' | 'fix_input' | 'cleanup' | 'manual'
  suggestions: string[]
}

interface ErrorMetrics {
  count: number
  lastOccurrence: Date
}

// ÂâµÂª∫ÂñÆ‰æãÂØ¶‰æã
export const errorTrackingService = new ErrorTrackingService()
